
"use strict";

var fileUtils = require('file-utils');
var path = require('path');
var crypto = require('crypto');

//得到回车换行符
function returnType(content){
      var linefeed = /\r\n/g.test(content) ? '\r\n' : '\n';
      return linefeed;
}


module.exports = ProcessorBase

function ProcessorBase(){
    /**
     * 得到需要处理的内容块对象
     * @param content 待处理的内容
     * @return {array}blocks 
     *         [{filePath:'' , 其他由处理器自己决定]
     */
    this.getBlocks = function(content){
        throw new Error('no implement');
    };
    
    /*
     * 根据模块路径替换为所需要的内容.
     * @param orgiContent 待替换的内容
     * @param block 替换块 块信息
     * @param targetFileName 替换的目标文件
     * @param returnType 回车换行符
     * @return 返回替换后的内容, 如果
     */
    this.replaceContent = function processContent(orgiContent , block , targetFileName , returnType){
         throw new Error('no implements');
    };
    
    //处理引用的文件内容
    /**
     * 处理获得的文件内容
     * @param {array}contents 文件内容
                     {string}filePath 文件路径
                     {String}content  文件内容
     * @param {string}returnType 文件的回车换行符
     * @param {object}globalConfig 全局配置对象
     * @param {Logger}logger 日志对象
     * @return 如果都成功则返回处理后的内容
     */
    this.processContent = function processContent(contents , returnType , globalConfig){
        //合并、检验、压缩文件
        throw new Error('no implements');
    };
    
    /**
     * 压缩文件
     */
    this.compressContent = function compressContent(content){
        return content;s
    }
    
    
    //得到lib的原始文件列表，为以后debug使用
    this.getOriginalMainFiles = function getOriginalMainFiles(){
        throw new Error('no implements');
    }
    
    /**
     * 处理的主类,需要
     * @param blockConfig 块信息
     * @param options 全局配置
     */
    this.processRun = function processRun(blockConfig , options){
        
        var blockContent = blockConfig.blockInnerContent; //文件块内容
        var targetFileName = blockConfig.targetFilePath;  //产生的目标文件名
        var contents = []; 
        var changedContent = blockConfig.blockOuterContent;
        var blocks = this.getBlocks(blockContent);
        var deleteFiles = [];
        
        for(var i=0 ; i<blocks.length ; i++){
            var block = blocks[i];
            var refFile = block.filePath; //引用的文件
            if(! (/^(http|https).*/i.test(refFile))){
                //如果是绝对路径 
                var filePath = path.join(options.appDir, refFile); //文件绝对路径
                if(fileUtils.exists(filePath)){
                   try{
                         contents.push({filePath:filePath , content:fileUtils.read(filePath)}); //得到文件内容
                         //完成后删除文件
                         fileUtils.delete(path.join(options.destPath, refFile), {force:true});
                   }catch(error){
                         console.warn(process.pid , error.message , filePath);
                   }
                }
            }
        }
        //处理文件内容  
        if(contents.length==0){
            return;
        }
        var concatContent = this.processContent(contents , targetFileName , returnType(blockConfig.blockOuterContent) , options );
        try{
            var compressedContent = this.compressContent(concatContent);  //压缩的内容
        }catch(error){
            console.log(error)
        }
        //拷贝压缩文件到dest路径
        var destPath = options.destPath; //目标发布的地址
        var md5suffix = this.md5Suffix(concatContent , 'md5' , 'hex'); //使用未压缩的数据处理名称
        var extname = path.extname(targetFileName);
        var fileNamePrefix = path.dirname(targetFileName)+'/'+ path.basename(targetFileName , extname)+'_'+md5suffix;
        var compressedFileName = fileNamePrefix+'.min'+extname;
        var concatFileName = fileNamePrefix+extname;
        var originalFiles = [];
        
        try{
            
            fileUtils.write(destPath+'/'+fileNamePrefix+'.min'+extname , compressedContent);  //压缩文件
            if(extname == '.css' || extname =='.js'){
                fileUtils.write(destPath+'/'+fileNamePrefix+extname , concatContent);  //写未压缩文件
            }
            //文件写入成功后处理块中的内容，加入到blockConfig中的changedContent
            blockConfig.compressedFileName = destPath +'/'+ compressedFileName;    //压缩文件名
            blockConfig.concatFileName = destPath +'/'+ concatFileName;            //未压缩的文件名
        }catch(error){
            console.error(process.pid , 'write concat css  file error.' , '');    
        }
        
        for(var i=0 ; i<blocks.length ; i++){
            var block = blocks[i];
            var refFile = block.filePath; //引用的文件
            if(! (/^(http|https).*/i.test(refFile))){
                changedContent =  this.replaceContent(changedContent , block , compressedFileName , returnType(blockConfig.blockOuterContent)); //替换文件内容  
            }
        }
        blockConfig.changedContent = changedContent; //转换后的文件
    };   
    
    this.md5Suffix  = function(content, algorithm, encoding) {
        var hash = crypto.createHash(algorithm);
        hash.update(content);
        hash = hash.digest(encoding);
        return hash.slice(0, 8);
    };
    
     
    
};





